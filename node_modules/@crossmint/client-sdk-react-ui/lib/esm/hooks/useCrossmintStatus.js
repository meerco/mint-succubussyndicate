import { useState, useEffect } from "react";
import { validate } from "uuid";
import { LIB_VERSION } from "../version";
import { clientNames, baseUrls, customHeaders } from "../types";
export var OnboardingRequestStatusResponse;
(function (OnboardingRequestStatusResponse) {
    OnboardingRequestStatusResponse["WAITING_SUBMISSION"] = "waiting-submission";
    OnboardingRequestStatusResponse["PENDING"] = "pending";
    OnboardingRequestStatusResponse["REJECTED"] = "rejected";
    OnboardingRequestStatusResponse["ACCEPTED"] = "accepted";
    OnboardingRequestStatusResponse["INVALID"] = "invalid";
})(OnboardingRequestStatusResponse || (OnboardingRequestStatusResponse = {}));
const validateClientId = (clientId) => {
    try {
        const isValid = validate(clientId);
        return !!isValid;
    }
    catch (e) {
        console.error(e);
        return false;
    }
};
export default function useCrossMintStatus({ clientId, development }) {
    const [status, setStatus] = useState(OnboardingRequestStatusResponse.WAITING_SUBMISSION);
    async function fetchClientIntegration() {
        if (!clientId || clientId === "" || clientId === "<YOUR_CLIENT_ID>") {
            console.error("You must enter your own Crossmint client ID in <CrossmintPayButton clientId=XXX>");
            return;
        }
        if (!validateClientId(clientId)) {
            console.error("The clientId passed to is invalid. Make sure to pass the clientId obtained from the crossmint team, with format XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXX");
            return;
        }
        const baseUrl = development ? baseUrls.dev : baseUrls.prod;
        const res = await fetch(`${baseUrl}/api/crossmint/onboardingRequests/${clientId}/status`, {
            headers: {
                [customHeaders.clientVersion]: LIB_VERSION,
                [customHeaders.clientName]: clientNames.reactUi,
            },
        });
        if (res.status === 200) {
            const resData = await res.json();
            setStatus(resData.status);
        }
        else {
            if (status !== OnboardingRequestStatusResponse.INVALID) {
                setStatus(OnboardingRequestStatusResponse.INVALID);
            }
        }
    }
    useEffect(() => {
        fetchClientIntegration();
        const interval = setInterval(() => {
            fetchClientIntegration();
        }, 60 * 1000);
        return () => clearInterval(interval);
    }, []);
    return status;
}
//# sourceMappingURL=useCrossmintStatus.js.map